<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="author" content="Naoki Nakajima" />
  <meta property="og:url" content="https://pps5.github.io/blog/fragment_arguments.html" />
  <meta property="og:title" content="Fragment の getArguments, requireArguments の使い分けについて - pps5" />
  <meta property="og:site_name" content="pps5" />
  <meta property="og:image" content="https://pps5.github.io/img/icon.png" />
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:title" content="Fragment の getArguments, requireArguments の使い分けについて - pps5" />
  <meta name="twitter:image" content="https://pps5.github.io/img/icon.png" />
  <meta name="description" content="Fragment の getArguments, requireArguments の使い分けについて" />
  <meta property="og:description" content="Fragment の getArguments, requireArguments の使い分けについて" />
  <meta name="twitter:description" content="Fragment の getArguments, requireArguments の使い分けについて" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fragment の getArguments, requireArguments の使い分けについて - pps5</title>
  <link rel="icon" href="/img/icon.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css"
    integrity="sha256-2YQRJMXD7pIAPHiXr0s+vlRWA7GYJEK0ARns7k2sbHY=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/obsidian.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Suez+One&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/style.css" />
</head>

<body>
  <main>
    <header>
      <span class="float-left">
        <a id="title" href="/">pps5</a>
      </span>
      <div class="cropper float-left">
        <a href="/"><img src="/img/icon.png" alt="pps5"></a>
      </div>
    </header>

    <article>
      
              <h1>Fragment の getArguments, requireArguments の使い分けについて</h1>
              <div>2020/08/17</div>
              <h2>
                <a name="-" class="dummy-anchor"></a>
                <a class="anchor" href="#-">
                  <i class="fa fa-link"></i>
                </a>
                それぞれのメソッドの違い
              </h2><p>Fragment に何か値を渡したいとき、今であれば Jetpack Navigation と SafeArgs を使うのが一番簡単で確実だと思いますが、古いプロジェクトだと必ずしもそうはいかないため今まで通りの実装をしなければなりません。</p>
<p>newInstance を利用した実装が一般的で、 Fragment を新しく作成するときは以下のように実装されたメソッドを使用します。</p>
<pre><code class="kotlin">class SampleFragment : Fragment() {

    companion object {
        private const val KEY = &quot;key&quot;

        fun newInstance(value: Int) {
            val f = SampleFragment()
            f.arguments = bundleOf(KEY, value)
            return f
        }
    }
}</code></pre>
<p>この値を取り出すときに用いるのが getArguments や requireArguments ですが、戻り値が Nullable かどうかが異なります。</p>
<pre><code class="kotlin">val args = getArguments
if (args != null) {
    val value = args.getInt(KEY)
    doSomething(value)
}</code></pre>
<pre><code class="kotlin">val value = requireArguments().getInt(KEY)
doSomething(value)</code></pre>
<p>requireArguments は内部的に null チェックを行っており、もし null であれば例外が発生します。したがって、この SampleFragment を直接コンストラクタで生成した場合、</p>
<ul>
<li>前者 (getArguments): doSomething は実行されないが、クラッシュもしない</li>
<li>後者 (requireArguments): 例外が発生してアプリがクラッシュする</li>
</ul>
<p>といった挙動になります。</p>

              <h2>
                <a name="-" class="dummy-anchor"></a>
                <a class="anchor" href="#-">
                  <i class="fa fa-link"></i>
                </a>
                どう使い分けるか
              </h2><p>基本的に全て requireArguments で問題ないはずです。</p>
<p>Fragment に何か値を渡すとき、それは Fragment で必ず使う値であることがほとんどです。たとえば、ある日にちのデータを表示する画面であれば日付は必要でしょうし、カテゴリに応じた内容を表示するならばカテゴリは必須であるはずです。</p>
<p>null チェックをして、データがあったときだけ画面を構築するようにしてしまうと、必要なデータがない異常な状態であっても正常に動作しているかのように見えてしまいます。Fragmentの使い方を間違っていることがわかるように、誤った初期化をしていれば即座にクラッシュさせたほうが開発中に気づきやすくなります。</p>
<p>値が渡されないことが想定される場合でも、必ず newInstance で arguments をセットすればそれで良いと思います。</p>
<pre><code class="kotlin">// bad
fun newInstance(value: Int?) {
    val f = SampleFragment()
    if (value != null) {
        f.arguments = bundleOf(KEY, value)
    }
    return f
}

// good
fun newInstance(value: Int?) {
    val f = SampleFragment()
    val args = Bundle()
    if (value != null) {
        args.putInt(value)
    }
    f.arguments = args
    return f
}</code></pre>
<p>これで少なくとも newInstance 経由でインスタンスを生成していれば getArguments が null になることがなくなります。そして requireArguments を使用していれば、たとえ誤って直接コンストラクタで生成したとしても例外が発生するため開発中に検出できるようになります。</p>

              <h2>
                <a name="-" class="dummy-anchor"></a>
                <a class="anchor" href="#-">
                  <i class="fa fa-link"></i>
                </a>
                まとめ
              </h2><p>なんだかんだ考えた結果、自分の中では全部 requireArguments で良いという結論に至りました。もしここに記載したもの以外で何かお気づきの点がありましたら、<a href="https://twitter.com/Inb_J">@Inb_J</a> までご連絡ください。</p>
<p>requireArguments の実装を見ると、例外を送出しているため実開発で使用するのに戸惑う人もいるかもしれませんが、例外は必ずしも悪いものではなく、開発段階で不正な状態を発見するのにも役立ちます。特に Android では Android 固有のライフサイクルによって、静的解析などで厳密にチェックすることも難しいこともあるため、こういった形で検証できるようにしたほうが良いでしょう。</p>

    </article>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"
    integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin="anonymous"></script>
  <script>
    hljs.initHighlightingOnLoad();
    document.addEventListener('DOMContentLoaded', (e) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
</body>

</html>